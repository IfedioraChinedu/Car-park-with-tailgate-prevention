// Libraries
#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <SPI.h>
#include <MFRC522.h>
#include <ESP32Servo.h>
#include <FS.h>
#include <SPIFFS.h>
#include <ArduinoJson.h>
#define TINY_GSM_MODEM_SIM800
#include <TinyGsmClient.h>

// Pin Configs 
#define RFID_SS 5
#define RFID_RST 22
#define SERVO_ENTRANCE_PIN 13
#define SERVO_EXIT_PIN 14
#define TRIG_ENTRANCE 26
#define ECHO_ENTRANCE 25
#define TRIG_EXIT 33
#define ECHO_EXIT 32
#define BUZZER_PIN 27
#define MODEM_TX 17
#define MODEM_RX 16
#define MODEM_BAUD 9600

// WiFi
const char* WIFI_SSID = "";
const char* WIFI_PASS = "";

// Termii
String termiiApiKey   = ""; // Set your API key
String termiiSenderID = ""; // Set your Sender ID
String termiiTo       = ""; // Set your destination phone number

// SPIFFS & Authorized UIDs
const char* authorizedFile = "/authorized.json";
DynamicJsonDocument authorizedDoc(1024);
JsonArray authorizedUIDs;

// RFID
MFRC522 mfrc522(RFID_SS, RFID_RST);

// Servo 
Servo entranceGateServo;
Servo exitGateServo;

// Gate & Sensor 
bool entranceGateOpen = false;
bool exitGateOpen = false;
unsigned long entranceGateOpenTime = 0;
unsigned long exitGateOpenTime = 0;
const unsigned long GATE_OPEN_DURATION = 5000;
const int ENTRANCE_DIST_THRESHOLD = 8;
const unsigned long CLEAR_DELAY = 3000;
const unsigned long TAMPER_TIME = 2000;
bool carBesideSensor = false;
unsigned long lastCarExitTime = 0;

// GSM 
TinyGsm modem(Serial2);

// Function Declarations
void sendTermiiSMS(String to, String message);
void sendGsmSMS(String to, String body);
bool isUIDAuthorized(String uid);
float readDistance(int trigPin, int echoPin);
void openEntranceGate();
void closeEntranceGate();
void openExitGate();
void closeExitGate();
void checkEntranceGateTimeout();
void checkExitGateTimeout();
void beepOnce(int duration);
void doubleBeep();
void longBeep();
void beepTamperAlert();
void checkEntranceUltrasonic();
void loadAuthorizedUIDs();

// Setup 
void setup() {
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, HIGH);
  delay(800);
  digitalWrite(BUZZER_PIN, LOW);

  Serial.begin(115200);
  Serial2.begin(MODEM_BAUD, SERIAL_8N1, MODEM_RX, MODEM_TX);
  delay(1000);
  Serial.println("System starting...");

  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  ESP32PWM::allocateTimer(2);
  ESP32PWM::allocateTimer(3);

  // SPI for RFID
  SPI.begin();
  mfrc522.PCD_Init();

  // Servos
  entranceGateServo.setPeriodHertz(50);
  entranceGateServo.attach(SERVO_ENTRANCE_PIN, 500, 2400);
  entranceGateServo.write(90);
  exitGateServo.setPeriodHertz(50);
  exitGateServo.attach(SERVO_EXIT_PIN, 500, 2400);
  exitGateServo.write(90);

  // Ultrasonics
  pinMode(TRIG_ENTRANCE, OUTPUT);
  pinMode(ECHO_ENTRANCE, INPUT);
  pinMode(TRIG_EXIT, OUTPUT);
  pinMode(ECHO_EXIT, INPUT);

  // SPIFFS
  if (!SPIFFS.begin(true)) {
    Serial.println("SPIFFS Mount Failed!");
  } else {
    Serial.println("SPIFFS mounted");
  }

  if (!SPIFFS.exists(authorizedFile)) {
    Serial.println("authorized.json not found! Creating default...");
    File file = SPIFFS.open(authorizedFile, FILE_WRITE);
    if (file) {
      DynamicJsonDocument doc(1024);
      JsonArray uids = doc.createNestedArray("uids");
      uids.add("A1B2C3D4");
      uids.add("12345678");
      serializeJson(doc, file);
      file.close();
      Serial.println("Default authorized.json created");
    } else {
      Serial.println("Failed to create authorized.json");
    }
  }

  loadAuthorizedUIDs();

  // WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("Connecting WiFi");
  for (int i = 0; i < 20 && WiFi.status() != WL_CONNECTED; i++) {
    delay(500);
    Serial.print(".");
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("Connected!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("Failed to connect to WiFi");
  }

  // GSM
  Serial.println("Initializing GSM...");
  if (!modem.restart()) {
    Serial.println("Modem restart failed");
  } else {
    Serial.println("Modem restarted");
  }
  if (!modem.waitForNetwork(15000)) {
    Serial.println("GSM network not found");
  } else {
    Serial.println("GSM network ready");
  }

  Serial.println("Setup complete");

  digitalWrite(BUZZER_PIN, HIGH);
  delay(800);
  digitalWrite(BUZZER_PIN, LOW);
}

// Loop
void loop() {
  checkEntranceGateTimeout();
  checkExitGateTimeout();

  // RFID Detection
  if (mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()) {
    String uidStr = "";
    for (byte i = 0; i < mfrc522.uid.size; i++) {
      if (mfrc522.uid.uidByte[i] < 0x10) uidStr += "0";
      uidStr += String(mfrc522.uid.uidByte[i], HEX);
    }
    uidStr.toUpperCase();
    Serial.println("RFID Detected - UID: " + uidStr);

    beepOnce(100);

    if (isUIDAuthorized(uidStr)) {
      Serial.println("Tag authorized — Access granted into park");
      openEntranceGate();
      doubleBeep();
    } else {
      Serial.println("Tag Unauthorized — Sending alert message to park owner");
      String message = "Warning: Unauthorized Vehicle (" + uidStr + ") detected at the parking entrance. UID: ";
      longBeep();
      sendTermiiSMS(termiiTo, message);
    }

    mfrc522.PICC_HaltA();
    mfrc522.PCD_StopCrypto1();
    delay(1000);
  }

  // Tailgate detection
  checkEntranceUltrasonic();

  // Exit gate detection
  float exitDist = readDistance(TRIG_EXIT, ECHO_EXIT);
  if (exitDist > 0 && exitDist < 8) {
    Serial.println("Vehicle exiting park — Exit gate opening");
    openExitGate();
  }

  delay(100);
}

// Authorized UID Functions 
void loadAuthorizedUIDs() {
  File file = SPIFFS.open(authorizedFile, FILE_READ);
  if (!file) return;
  DeserializationError error = deserializeJson(authorizedDoc, file);
  file.close();
  if (!error) authorizedUIDs = authorizedDoc["uids"].as<JsonArray>();
}

bool isUIDAuthorized(String uid) {
  for (JsonVariant value : authorizedUIDs) {
    if (value.as<String>().equalsIgnoreCase(uid)) return true;
  }
  return false;
}

// Gate Control 
void openEntranceGate() {
  if (!entranceGateOpen) {
    entranceGateServo.write(0);
    entranceGateOpen = true;
    entranceGateOpenTime = millis();
    doubleBeep();
  }
}

void closeEntranceGate() {
  if (entranceGateOpen) {
    entranceGateServo.write(90);
    entranceGateOpen = false;
    doubleBeep();
  }
}

void checkEntranceGateTimeout() {
  if (entranceGateOpen && (millis() - entranceGateOpenTime >= GATE_OPEN_DURATION))
    closeEntranceGate();
}

void openExitGate() {
  if (!exitGateOpen) {
    exitGateServo.write(0);
    exitGateOpen = true;
    exitGateOpenTime = millis();
    doubleBeep();
  }
}

void closeExitGate() {
  if (exitGateOpen) {
    exitGateServo.write(90);
    exitGateOpen = false;
    doubleBeep();
  }
}

void checkExitGateTimeout() {
  if (exitGateOpen && (millis() - exitGateOpenTime >= GATE_OPEN_DURATION))
    closeExitGate();
}

// Ultrasonic
float readDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH, 30000);
  if (duration == 0) return -1;
  return duration * 0.034 / 2;
}

void checkEntranceUltrasonic() {
  float distance = readDistance(TRIG_ENTRANCE, ECHO_ENTRANCE);
  if (distance < 0) return;

  if (distance < ENTRANCE_DIST_THRESHOLD && !carBesideSensor) {
    unsigned long timeSinceLastCar = millis() - lastCarExitTime;
    if (timeSinceLastCar < TAMPER_TIME && lastCarExitTime > 0) {
      beepTamperAlert();
      sendTermiiSMS(termiiTo, "Alert! Alert!, Tailgating detected at car park.");
      return;
    }
    carBesideSensor = true;
    beepOnce(150);
  } else if (distance >= ENTRANCE_DIST_THRESHOLD && carBesideSensor) {
    carBesideSensor = false;
    lastCarExitTime = millis();
  }
}

// Buzzer 
void beepOnce(int duration) {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(duration);
  digitalWrite(BUZZER_PIN, LOW);
}

void doubleBeep() {
  beepOnce(100);
  delay(100);
  beepOnce(150);
}

void longBeep() {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(600);
  digitalWrite(BUZZER_PIN, LOW);
}

void beepTamperAlert() {
  beepOnce(100);
  delay(100);
  beepOnce(100);
}

// SMS
void sendTermiiSMS(String to, String message) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String url = "https://api.ng.termii.com/api/sms/send";
    http.begin(url);
    http.addHeader("Content-Type", "application/json");

    String payload = "{";
    payload += "\"to\":\"" + to + "\",";
    payload += "\"from\":\"" + termiiSenderID + "\",";
    payload += "\"sms\":\"" + message + "\",";
    payload += "\"type\":\"plain\",";
    payload += "\"channel\":\"generic\",";
    payload += "\"api_key\":\"" + termiiApiKey + "\"";
    payload += "}";

    int code = http.POST(payload);
    if (code > 0) {
      Serial.println("Termii Response: " + http.getString());
    } else {
      Serial.println("Termii SMS failed: " + String(code));
    }
    http.end();
  } else {
    sendGsmSMS(to, message);
  }
}

void sendGsmSMS(String to, String body) {
  if (!modem.isNetworkConnected()) {
    if (!modem.waitForNetwork(10000)) return;
  }
  modem.sendSMS(to, body);

}

